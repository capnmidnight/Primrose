"use strict";

var url = require("url"),
    requireDirectory = require("./requireDirectory"),
    Message = require("./Message"),
    options = require("./options").parse(process.argv),
    isDev = options.mode === "dev" || process.env.NODE_ENV === "dev";

var routes = [
  require("./controllers/logger"),
  require("./controllers/defaultGET")
];

function findController(request) {
  var accept = request.headers.accept,
      method = request.method,
      url = request.url;

  for (var i = 0; i < routes.length; ++i) {
    var route = routes[i],
        pattern = route.URLPattern,
        match = url.match(pattern);

    if (match) {
      var handlers = route[method];
      if (handlers) {
        for (var type in handlers) {
          var handler = handlers[type];
          if (type === "*/*" || accept.indexOf(type) >= 0) {
            for (var k = 1; k < match.length; ++k) {
              handler = handler.bind(null, match[k]);
            }
            return handler;
          }
        }
        return function () {
          return Message.NotAcceptable;
        };
      } else {
        return function () {
          return Message.MethodNotAllowed;
        };
      }
    }
  }
  return function () {
    return Message.NotFound;
  };
}

function parseBody(request) {
  return new Promise(function (resolve, reject) {
    var body = [],
        size = 0,
        len = 0;
    request.on("data", function (chunk) {
      body.push(chunk);
      if (size === 0) {
        len = request.headers["content-length"];
        if (len === undefined || len === null) {
          reject(Message.LengthRequired);
        } else {
          len = parseFloat(len);
        }

        size += chunk.length;
      }

      if (size > 5e6) {
        reject(Message.PayloadTooLarge);
      }
    }).on("end", function () {
      var text = Buffer.concat(body).toString();
      if (text.length === 0) {
        resolve();
      } else {
        var type = request.headers["content-type"];
        if (!type) {
          reject(Message.BadRequest);
        } else if (len !== text.length) {
          reject(Message.BadRequest);
        } else {
          try {
            if (type.indexOf("application/json") > -1) {
              text = JSON.parse(text);
            }
            resolve(text);
          } catch (exp) {
            reject(Message.BadRequest);
          }
        }
      }
    }).on("error", reject);
  });
}

function parseCookies(request, body) {
  if (request.headers.cookie) {
    return request.headers.cookie.split(";").map(function (s) {
      return s.trim();
    }).map(function (s) {
      return s.split("=");
    }).map(function (arr) {
      var obj = {};
      obj[arr[0]] = arr.length === 1 || arr[1];
      return obj;
    });
  }
}

module.exports = function (serveRoot, controllerDirectory) {
  serveRoot = serveRoot || ".";
  if (controllerDirectory) {
    var controllers = requireDirectory(controllerDirectory).filter(function (r) {
      return !!r.URLPattern;
    });
    routes.unshift.apply(routes, controllers);
  }
  return function serveRequest(request, response) {
    return parseBody(request).then(function (body) {
      return {
        url: request.url,
        body: body,
        cookies: parseCookies(request),
        headers: request.headers,
        root: serveRoot
      };
    }).then(function (state) {
      return findController(request)(state);
    }).catch(function (err) {
      return err instanceof Message ? err : Message.InternalServerError;
    }).then(function (msg) {
      return msg.send(response);
    });
  };
};