"use strict";

var fs = require("fs"),
  url = require("url"),
  mime = require("mime"),
  Message = require("../Message"),
  redirect = require("./redirect"),
  options = require("../options").parse(process.argv),
  isDev = options.mode === "dev" || process.env.NODE_ENV === "dev",
  fullFile = require("./fullFile"),
  noContent = require("./noContent"),
  partialRequest = require("./partialRequest"),
  rangeNotSatisfiable = require("./rangeNotSatisfiable"),
  etag = require("etag");

function fileIsNewer(cacheControl, ifModSince, fileModDate) {
  if(cacheControl === "no-cache" || !ifModSince) {
    return true;
  }
  else {
    var ifModSinceDate = new Date(Date.parse(ifModSince)),
      aTime = ifModSinceDate.getTime(),
      bTime = fileModDate.getTime(),
      delta = bTime - aTime,
      max = 0;

    if(cacheControl) {
      var m = cacheControl.match(/max-age=(\d+)/);
      if(m) {
        max = parseFloat(m[1]);
      }
    }

    return delta >= max;
  }
}


module.exports = function file(fileName, state) {

  return new Promise(function (resolve, reject) {
    fs.lstat(fileName, function (err, stat) {
      if (err) {
        resolve(Message.NotFound);
      } else if (stat.isDirectory()) {
        var parts = url.parse(state.url);
        parts.pathname += "/";
        resolve(redirect(url.format(parts)));
      } else if (!fileIsNewer(state.headers["cache-control"], state.headers["if-modified-since"], stat.mtime)) {
        resolve(Message.NotModified);
      }
      else if(!state.headers.range) {
        resolve(fullFile(fileName, stat.size, stat.mtime, etag(stat)));
      }
      else {
        var parts = state.headers.range.replace(/bytes=/, "").split("-"),
            partialStart = parts[0],
            partialEnd = parts[1],
            hasStart = partialStart.length > 0,
            hasEnd = partialEnd.length > 0,
            start = hasStart ? parseInt(partialStart, 10): 0,
            end = hasEnd ? parseInt(partialEnd, 10) : stat.size - 1,
            chunkSize = (end - start + 1);

        if(start < 0 || stat.size <= start
          || end < 0 || stat.size <= end
          || chunkSize < 0 || stat.size < chunkSize) {
          resolve(rangeNotSatisfiable(stat.size));
        }
        else {
          resolve(partialRequest(fileName, stat.mtime, start, end, etag(stat)));
        }
      }
    });
  });
}